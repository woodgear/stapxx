
#!/usr/bin/env stap++


global jitted

probe begin
{
    warn(sprintf("Start tracing %d ($^exec_path)\n", target()))
    %( "$^arg_time" != ""  %?
    warn(sprintf("Please wait for $^arg_time seconds...\n"))
    %:
    warn("Hit Ctrl-C to end.\n")
    %)
}

probe timer.profile
{
    if (pid() == target()) {
        start =  local_clock_ns()
        process_event()
        end = local_clock_ns() 
        printf("diff %d ns \n",end-start)
    }
}

probe timer.s(1)
{
    printf("time up %ds. jitted %d\n",1,jitted)
    exit()
}

probe end {
    warn("end.\n")
}

function process_event() {
    # ml: lua_State
    mL = ngx_lua_get_main_lua_vm()
    printf("wg: ml %x\n",mL)

    # g: global_State
    g = luajit_G(mL)
    printf("wg: g %x\n",g)

    # L: lua_State 
    l = luajit_cur_thread(g)
    printf("wg: cur_L %x \n",l)
    printf("wg: status  %d \n",lua_state_status(l))

    vmstate = luajit_global_State_vmstate(g)
    printf("wg: vmstate  %d \n",vmstate)

    if (vmstate >= 0) {
        jitted++
    }
}


function ngx_lua_get_main_lua_vm()
{
    if (@defined(@var("globalL", "$^exec_path"))) {
        mL = @var("globalL", "$^exec_path")
        printf("wg: ml from globalL\n")
        return mL
    }
    printf("wg: ml from ngx_http_lua_main_conf_t\n")
    lmcf = ngx_lua_cycle_get_main_conf()
    if (lmcf) {
        $*lmcf := @cast(lmcf, "ngx_http_lua_main_conf_t", "$^exec_path")
        return $*lmcf->lua
    }
    return 0
}

function ngx_lua_cycle_get_main_conf()
{
    return ngx_cycle_get_module_main_conf(@var("ngx_cycle", "$^exec_path"),
                                       @var("ngx_http_lua_module", "$^exec_path")->ctx_index)
}


function ngx_cycle_get_module_main_conf(cycle, module_index)
{
    $*cycle := @cast(cycle, "ngx_cycle_t", "$^exec_path")
    http_index = @var("ngx_http_module", "$^exec_path")->index

    printf("wg: http index %d http-lua index %d \n",http_index,module_index)

    ctx = $*cycle->conf_ctx[http_index]
    if (ctx == 0) {
        return 0
    }
    $*ctx := @cast(ctx, "ngx_http_conf_ctx_t", "$^exec_path")
    return $*ctx->main_conf[module_index]
}


# luajit
function luajit_G(L)
{
    $*L := @cast(L, "lua_State", "$^libluajit_path")
    return $*L->glref->ptr64
}


function luajit_cur_thread(g)
{
    $*g := @cast(g, "global_State", "$^libluajit_path")
    gco = $*g->cur_L->gcptr64
    if (gco == 0) {
        return 0
    }
    $*gco := @cast(gco, "GCobj", "$^libluajit_path")
    printf("wg: cur_thread %x\n",&$*gco->th)
    return &$*gco->th
}

function lua_state_status(l) {
   $*tl := @cast(l, "lua_State", "$^libluajit_path")
   return $*tl->status
}


function luajit_global_State_vmstate(g)
{
    return @cast(g, "global_State", "$^libluajit_path")->vmstate
}