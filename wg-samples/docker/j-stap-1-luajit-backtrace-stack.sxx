#!/usr/bin/env stap++

@define LJ_VMST_INTERP %( 0 %)
@define LJ_VMST_C %( 1 %)
@define LJ_VMST_GC %( 2 %)

global jitted
global vmst_gc
global nojitted 
global g_cost 
global bts  # map, key:bt,val: count

probe begin
{
    warn(sprintf("Start tracing %d ($^exec_path)\n", target()))
    %( "$^arg_time" != ""  %?
    warn(sprintf("Please wait for $^arg_time seconds...\n"))
    %:
    warn("Hit Ctrl-C to end.\n")
    %)
}

probe timer.profile
{
    if (pid() == target()) {
        start =  local_clock_ns()
        process_event()
        end = local_clock_ns() 
        cost = end-start
        g_cost+= cost
        printf("wg: e-cost %d ns \n",cost)
    }
}


function process_event() {
    # ml: lua_State
    mL = ngx_lua_get_main_lua_vm()
    printf("wg: ml %x\n",mL)

    # g: global_State
    g = luajit_G(mL)
    $*g := @cast(g, "global_State", "/proc/2091042/root/openresty-wg/target/luajit/lib/libluajit-5.1.so.2")
    printf("wg: g %x\n",g)

    # L: lua_State 
    l = luajit_cur_thread(g)
    printf("wg: cur_L %x \n",l)
    printf("wg: status  %d \n",lua_state_status(l))

    vmstate = luajit_global_State_vmstate(g)
    printf("wg: vmstate  %d \n",vmstate)

    vmst_gc = (vmstate == ~@LJ_VMST_GC && $*g->jit_base->ptr64)
    if (vmstate >= 0) {
        jitted++
    } else if (vmst_gc) {
        vmst_gc++
    } else {
        nojitted++
    }

    bt =  luajit_backtrace(l,g)
    if (bt=="") {
        printf("stack warn wg: empty bt\n")
        return 0
    }
    f = probefunc()
    if (f != "") {
        // wg: keep it in same line,we will replace |lb| to real line-break later
        bt = "|pf-s|".f ."|pf-e|". "|lb|" . bt
    }
    printf("stack wg: bt  %s\n",bt)
    bts[bt] <<< 1
    return 1
}

probe timer.s($^arg_time :default(30))
{
    exit()
}

probe end {
    time=$^arg_time
    ns = g_cost
    ms = g_cost/1000000
    s = ms /1000
    msg = sprintf("wg: end. time %d jitted %d %d %d cost %dns %dms %ds\n",time,jitted,nojitted,vmst_gc,ns,ms,s)
    output_report()
    print(msg)
    warn(msg)
}

function output_report() {
    max=$^arg_limit :default(1000)
    min=$^arg_min :default(2)
    foreach (bt in bts- limit max) {
        cnt = @count(bts[bt])
        printf("report wg: %s %d\n",bt,cnt)
        if (cnt <= min) {
            break
        }
        printf("report:%s|lt|%d\n", bt, cnt)
    }
}

function ngx_lua_get_main_lua_vm()
{
    if (@defined(@var("globalL", "$^exec_path"))) {
        mL = @var("globalL", "$^exec_path")
        printf("wg: ml from globalL\n")
        return mL
    }
    printf("wg: ml from ngx_http_lua_main_conf_t\n")
    lmcf = ngx_lua_cycle_get_main_conf()
    if (lmcf) {
        $*lmcf := @cast(lmcf, "ngx_http_lua_main_conf_t", "$^exec_path")
        return $*lmcf->lua
    }
    return 0
}

function ngx_lua_cycle_get_main_conf()
{
    return ngx_cycle_get_module_main_conf(@var("ngx_cycle", "$^exec_path"),
                                       @var("ngx_http_lua_module", "$^exec_path")->ctx_index)
}


function ngx_cycle_get_module_main_conf(cycle, module_index)
{
    $*cycle := @cast(cycle, "ngx_cycle_t", "$^exec_path")
    http_index = @var("ngx_http_module", "$^exec_path")->index

    printf("wg: http index %d http-lua index %d \n",http_index,module_index)

    ctx = $*cycle->conf_ctx[http_index]
    if (ctx == 0) {
        return 0
    }
    $*ctx := @cast(ctx, "ngx_http_conf_ctx_t", "$^exec_path")
    return $*ctx->main_conf[module_index]
}


# luajit
function luajit_G(L)
{
    $*L := @cast(L, "lua_State", "/proc/2091042/root/openresty-wg/target/luajit/lib/libluajit-5.1.so.2")
    return $*L->glref->ptr64
}


function luajit_cur_thread(g)
{
    $*g := @cast(g, "global_State", "/proc/2091042/root/openresty-wg/target/luajit/lib/libluajit-5.1.so.2")
    gco = $*g->cur_L->gcptr64
    if (gco == 0) {
        return 0
    }
    $*gco := @cast(gco, "GCobj", "/proc/2091042/root/openresty-wg/target/luajit/lib/libluajit-5.1.so.2")
    printf("wg: cur_thread %x\n",&$*gco->th)
    return &$*gco->th
}

function lua_state_status(l) {
   $*tl := @cast(l, "lua_State", "/proc/2091042/root/openresty-wg/target/luajit/lib/libluajit-5.1.so.2")
   return $*tl->status
}


function luajit_global_State_vmstate(g)
{
    return @cast(g, "global_State", "/proc/2091042/root/openresty-wg/target/luajit/lib/libluajit-5.1.so.2")->vmstate
}


function luajit_backtrace(l, g) {
    # l: lua_State
    # g: global_State

    $*l := @cast(l, "lua_State", "/proc/2091042/root/openresty-wg/target/luajit/lib/libluajit-5.1.so.2")

    bt = ""

    base = $*g->jit_base->ptr64
    vmstate = $*g->vmstate
    native_jited_code = vmstate >= 0
    vmst_gc_with_base = (vmstate == ~@LJ_VMST_GC && $*g->jit_base->ptr64)
    vm_interp = vmstate == ~@LJ_VMST_INTERP 
    vm_interp_no_cframe = vmstate == ~@LJ_VMST_INTERP && !$*l->cframe 
    vm_c = vmstate == ~@LJ_VMST_C
    vm_gc = vmstate == ~@LJ_VMST_GC
    # ~@LJ_VMST_GC -3

    printf("trace wg: native_jited_code %d vmst_gc %d\n", native_jited_code,vmst_gc_with_base)

    // wg: the origin logic are native_jited_code || vmst_gc
    if (native_jited_code) {
        traceno = vmstate 
        t = luajit_get_trace(g, traceno)
        printf("trace wg: traceno %d t %x \n",traceno,t)

        func= luajit_trace_starting_func(l,t)
        printf("trace wg: func %s \n",func)
        bt .="|trace-f|"
        bt .=func

        if (base) {
            bt.="|stack|"
            bt .=luajit_debug_dumpstack(l,t,30,base,1)
        }
        return bt
    } 
    // is seems buggy when try go get fn when gc
    if (vmst_gc_with_base) {
        // TODO crash here
        printf("trace wg: gc\n")
        return "err:vmst_gc_with_base"
    }
    // wg: !native_jited_code && ! vmst_gc

    if (vm_interp_no_cframe) {
        printf("trace wg: interp but not cframe\n")
        return "err:vm_interp_no_cframe"
    }
    # wg: 当前正常执行的是c函数
    if (vm_c) {
        // TODO may crash here
        printf("trace wg: vm_interp %d  vm_c %d vm_gc %d\n",vm_interp,vm_c,vm_gc)
        base_tv = $*l->base
        bt_fn= luajit_debug_dumpstack(l, 0, 3, base_tv,1)
        if (bt_fn=="") {
            bt_fn = "err:empty_vmc_fn"
        }
        printf("trace wg: vm x state bt %s\n",bt_fn)
        bt.="|vm_c|"

        bt.=bt_fn
        return bt
    }
    if ( vm_interp  ) {
        return "err:vm_xstate_interp"
    }
    if ( vm_gc  ) {
        return "err:vm_xstate_gc"
    }
    return "err:noway"
}

function luajit_get_trace(g, traceno)
{
    printf("trace wg: get trace %x %d\n",g,traceno)
    # offsetoff
    zg  = &@cast(0, "GG_State", "/proc/2091042/root/openresty-wg/target/luajit/lib/libluajit-5.1.so.2")->g
    GG = g - zg
    printf("trace wg: zg %d g %x gg %x\n",zg,g,GG)
    $*GG := @cast(GG, "GG_State", "/proc/2091042/root/openresty-wg/target/luajit/lib/libluajit-5.1.so.2")
    J = &$*GG->J
    $*J := @cast(J, "jit_State", "/proc/2091042/root/openresty-wg/target/luajit/lib/libluajit-5.1.so.2")
    if (J == 0) {
        return 0
    }

    return $*J->trace[traceno]->gcptr64
}


function luajit_trace_starting_func(g, trace)
{
    $*trace := @cast(trace, "GCtrace", "/proc/2091042/root/openresty-wg/target/luajit/lib/libluajit-5.1.so.2")
    gco = $*trace->startpt->gcptr64
    if (gco == 0) {
        return ""
    }
    pt = &$*gco->pt
    $*pt := @cast(pt, "GCproto", "/proc/2091042/root/openresty-wg/target/luajit/lib/libluajit-5.1.so.2")

    firstline = $*pt->firstline
    printf("trace wg: firstline %d\n",firstline)

    name = luajit_proto_chunkname(pt)  /* GCstr *name */
    printf("trace wg: chunkname len %d \n",name->len)
    printf("trace wg: path %s\n",path)
    path = luajit_unbox_gcstr(name)
    return sprintf("%s:%d", path, firstline)
}

function luajit_proto_chunkname(pt) {
    $*pt := @cast(pt, "GCproto", "/proc/2091042/root/openresty-wg/target/luajit/lib/libluajit-5.1.so.2")
    gco = $*pt->chunkname->gcptr64
    $*gco := @cast(gco, "GCobj", "/proc/2091042/root/openresty-wg/target/luajit/lib/libluajit-5.1.so.2")
    return &$*gco->str
}

@define sizeof_GCstr %( &@cast(0, "GCstr", "/proc/2091042/root/openresty-wg/target/luajit/lib/libluajit-5.1.so.2")[1] %)
@define strdata(s) %(
    (@s + @sizeof_GCstr)
%)

/* convert GCstr to stap string */
function luajit_unbox_gcstr(gcs)
{
    $*gcs := @cast(gcs, "GCstr", "/proc/2091042/root/openresty-wg/target/luajit/lib/libluajit-5.1.so.2")
    printf("trace wg: gcstr %x\n",gcs)
    if (gcs == 0) {
        return ""
    }

   $*gcs := @cast(gcs, "GCstr", "/proc/2091042/root/openresty-wg/target/luajit/lib/libluajit-5.1.so.2")
   src = @strdata(gcs)
   printf("trace wg: gcstr src %x len %d\n",src,$*gcs->len)
   return user_string_n_warn(src, $*gcs->len)
}


@define LJ_GCVMASK %( 140737488355327 %)

@define gcrefu(frame) %(
    @cast(@frame, "TValue", "/proc/2091042/root/openresty-wg/target/luajit/lib/libluajit-5.1.so.2")->gcr->gcptr64
%)

@define gcval(frame) %(
    (@gcrefu(@frame) & @LJ_GCVMASK)
%)

@define frame_gc(frame) %(
    @gcval(@frame - @sizeof_TValue)
%)


@define FF_LUA %( 0 %)
@define FF_C   %( 1 %)

@define FRAME_LUA   %( 0 %)
@define FRAME_CONT  %( 2 %)
@define FRAME_TYPE  %( 3 %)
@define FRAME_P     %( 4 %)
@define FRAME_TYPEP %( (@FRAME_TYPE|@FRAME_P) %)

@define frame_ftsz(tv) %(
    @cast(@tv, "TValue", "/proc/2091042/root/openresty-wg/target/luajit/lib/libluajit-5.1.so.2")->ftsz
%)

@define frame_type(f) %(
    (@frame_ftsz(@f) & @FRAME_TYPE)
%)

@define frame_typep(f) %(
    (@frame_ftsz(@f) & @FRAME_TYPEP)
%)
@define frame_islua(f) %(
    (@frame_type(@f) == @FRAME_LUA)
%)

@define sizeof_TValue  %( &@cast(0, "TValue", "/proc/2091042/root/openresty-wg/target/luajit/lib/libluajit-5.1.so.2")[1] %)





@define frame_pc(tv) %(
    @cast(@tv, "TValue", "/proc/2091042/root/openresty-wg/target/luajit/lib/libluajit-5.1.so.2")->ftsz
%)

@define frame_contpc(f) %(
    (@frame_pc(@f - 2 * @sizeof_TValue))
%)

@define bc_a(i) %(
    ((@i >> 8) & 0xff)
%)


@define LJ_FR2 %( 1 %)
// 计算前一帧的位置
@define frame_prevl(f) %(
    (@f - (1 + @LJ_FR2 + @bc_a(user_uint32(@frame_pc(@f) - 4))) * @sizeof_TValue)
%)

@define FRAME_VARG  %( 3 %)

@define frame_isvarg(f) %(
    (@frame_typep(@f) == @FRAME_VARG)
%)

@define frame_sized(f) %(
    (@frame_ftsz(@f) & ~@FRAME_TYPEP)
%)

@define frame_prevd(f) %(
    (@f - @frame_sized(@f))
%)

@define isluafunc(fn) %(
    (@cast(@fn, "GCfunc", "/proc/2091042/root/openresty-wg/target/luajit/lib/libluajit-5.1.so.2")->c->ffid == @FF_LUA)
%)

@define isffunc(fn) %(
    (@cast(@fn, "GCfunc", "/proc/2091042/root/openresty-wg/target/luajit/lib/libluajit-5.1.so.2")->c->ffid > @FF_C)
%)

@define sizeof_GCproto %( &@cast(0, "GCproto", "/proc/2091042/root/openresty-wg/target/luajit/lib/libluajit-5.1.so.2")[1] %)

@define funcproto(fn) %(
    (@cast(@fn, "GCfunc", "/proc/2091042/root/openresty-wg/target/luajit/lib/libluajit-5.1.so.2")->l->pc->ptr64 - @sizeof_GCproto)
%)

@define proto_bc(pt) %(
    (@pt + @sizeof_GCproto)
%)

@define proto_bcpos(pt, pc) %(
    ((@pc - @proto_bc(@pt)) / @sizeof_TValue)
%)

@define proto_lineinfo(pt) %(
    @cast(@pt, "GCproto", "/proc/2091042/root/openresty-wg/target/luajit/lib/libluajit-5.1.so.2")->lineinfo->ptr64
%)
@define frame_iscont(f) %(
    (@frame_typep(@f) == @FRAME_CONT)
%)
@define NO_BCPOS    %( ~0 %)


@define sizeof_BCIns %( &@cast(0, "BCIns", "/proc/2091042/root/openresty-wg/target/luajit/lib/libluajit-5.1.so.2")[1] %)


function luajit_debug_dumpstack(l, t, depth, base, simple) {
    printf("wg: dump stack\n")
    level = 0
    dir = 1
    //wg: 从上到下还是从下到上去找调用栈
    if (depth < 0) { // reverse frames
        level = ~depth //wg: ? ~-1=0 ~-2=1
        depth = dir = -1
    }
    bt = ""

    $*l := @cast(l, "lua_State", "/proc/2091042/root/openresty-wg/target/luajit/lib/libluajit-5.1.so.2")
    while (level != depth) {
        // wg:栈底
        bot = $*l->stack->ptr64 + @sizeof_TValue //@LJ_FR2
        printf("wg: base %x bot %x diff %d stv %d level %d depth %d \n",base, bot,base-bot,@sizeof_TValue,level,depth)
        found_frame = 0
        // wg:这里可以想办法优化下吧
        tmp_level = level

        /* Traverse frames backwards. */
        for (nextframe = frame = base - @sizeof_TValue; frame > bot; ) {
            printf("wg: frame %x bot %x diff %d \n",frame,bot,frame-bot)
            if (@frame_gc(frame) == l) {
                printf("wg: frame gc ==l \n")
                tmp_level++
            }
            if (tmp_level-- == 0) {
                size = (nextframe - frame) / @sizeof_TValue
                printf("wg: break tmp level %d size %d nextf %x f %x \n",tmp_level,size,nextframe,frame)
                found_frame = 1
                break
            }
            nextframe = frame
            printf("wg: nextframe %x tmp level %d\n",nextframe,tmp_level)

            if (@frame_islua(frame)) {
                frame = @frame_prevl(frame)
                printf("wg: lua frame %x\n",frame)
            } else {
                if (@frame_isvarg(frame)) {
                    printf("wg: vararg frame \n")
                    tmp_level++;  /* Skip vararg pseudo-frame. */
                }
                frame = @frame_prevd(frame);
                printf("wg: prevd frame %x\n",frame)
            }
        }

        if (!found_frame) {
            frame = 0
            size = tmp_level
        }            

        // wg: 找到了一帧
        if (frame) {
            bt_fn = luajit_frame_parse_func(l,t,frame,size,simple) 
            printf("ds wg: get stack %s level %d/%d\n",bt_fn,level,depth)
            bt.="|stack-fs|"
            bt.=bt_fn
            bt.="|stack-fe|"
        } else if (dir == 1) {
            // wg ?
            printf("wg: no frame break \n")
            if (bt=="") {
                return "err:none-frame"
            }
            return bt
        } else {
            // wg ?
            level -= size
        }
        level += dir
    }
    if (bt=="") {
        return "err:none-frame:noloop"
    }
    return bt
}

function luajit_frame_parse_func(l,t,frame,size,simple) {
    nextframe = size ? frame + size * @sizeof_TValue : 0
    printf("frame wg: find a frame,start %x end(next) %x size %d\n",frame,nextframe,size)

    fn = luajit_frame_func(frame)
    if (fn == 0) {
        printf("frame warn wg: no fn find from frame\n")
        return "err:empty-fn"
    }
    # TODO DONT KNOW WHY BUT A HACK PATCH HEREE
    if (fn==0x7fffffffffff) {
        return "err:0x7f"
    }
    printf("frame debug wg: fn %x\n",fn)
    if (@isluafunc(fn)) {
        printf("wg: find luafunc \n")
        pt = @funcproto(fn)
        $*pt := @cast(pt, "GCproto", "/proc/2091042/root/openresty-wg/target/luajit/lib/libluajit-5.1.so.2")

        // try to get linenum
        if (simple) {
            line = $*pt->firstline
        } else {
            line = luajit_debug_frameline(l, t, fn, pt, nextframe)
            if (line < 0) {
                printf("frame warn wg: debug_frameline fail %d\n",line)
                line = $*pt->firstline
            } else {
                printf("frame wg: debug_frameline success %d\n",line)
            }
        }

        name = luajit_proto_chunkname(pt)  /* GCstr *name */
        if (name == 0) {
            printf("frame wg: proto chunkname fail\n")
            return "err:empty-chunk"
        }
        path = luajit_unbox_gcstr(name)
        bt = sprintf("%s:%d", path, line)
        printf("frame wg: proto chunkname success %s\n",bt)
        return bt
    } 
    if (@isffunc(fn)) {
        printf("frame warn wg: find ffn\n")
        return "err:ffn"
    } 
        /* C function */
    printf("frame warn wg: find c fn\n")
    return "err:cfn"
}

function luajit_frame_func(f) {
    gco = @frame_gc(f)
    $*gco := @cast(gco, "GCobj", "/proc/2091042/root/openresty-wg/target/luajit/lib/libluajit-5.1.so.2")
    return &$*gco->fn
}


function luajit_debug_frameline(l, t, fn, pt, nextframe)
{
    pc = luajit_debug_framepc(l, t, fn, pt, nextframe)
    if (pc != @NO_BCPOS) {
        if (pc <= $*pt->sizebc) {
            return luajit_debug_line(pt, pc)
        }
    }

    return -1
}


function luajit_debug_framepc(l, t, fn, pt, nextframe) {
    $*t := @cast(t, "GCtrace", "/proc/2091042/root/openresty-wg/target/luajit/lib/libluajit-5.1.so.2")

    printf("wg: debug framepc: L=%p, fn=%p, nextframe=%p\n", l, fn, nextframe)
    if (nextframe == 0) {
        return @NO_BCPOS
    }

    if (@frame_islua(nextframe)) {
        ins = @frame_pc(nextframe);
        printf("wg: frame is lua, ins = %p\n", ins)

    } else if (@frame_iscont(nextframe)) {
        println("wg: frame is cont")
        ins = @frame_contpc(nextframe)

    } else {
        /* TODO: add support for cframe */
    }

    printf("wg: debug framepc: ins = %p\n", ins)
    pos = @proto_bcpos(pt, ins) - 1;
    printf("wg: debug framepc: pos = %d\n", pos)
    sizebc = $*pt->sizebc
    printf("wg: debug framepc: ins = %p, pos=%d, sizebc=%d\n", ins, pos, sizebc)
    if (pos > sizebc) {
        printf("wg: Undo the effects of lj_trace_exit for JLOOP.\n")
        if (!t) {
            t = ins - 1 * @sizeof_BCIns - &@cast(0, "GCtrace", "/proc/2091042/root/openresty-wg/target/luajit/lib/libluajit-5.1.so.2")->startins;
        }
        printf("wg: startpc: %d\n", $*t->startpc->ptr64)
        pos = @proto_bcpos(pt, $*t->startpc->ptr64);
        printf("wg: Found adjusted position: %d\n", pos)
    }
    return pos;
}

function luajit_debug_line(pt, pc)
{
    lineinfo = @proto_lineinfo(pt)
    printf("wg: lj_debug_line: lineinfo = %p, %x <= %x\\n", lineinfo,pc, $*pt->sizebc)
    sizebc = $*pt->sizebc

    if (pc <= sizebc && lineinfo) {
        first = $*pt->firstline

        if (pc == sizebc) {
            return first + $*pt->numline
        }

        if (pc-- == 0) {
            return first
        }

        if ($*pt->numline < 256) {
            return first + @cast(lineinfo, "uint8_t", "/proc/2091042/root/openresty-wg/target/luajit/lib/libluajit-5.1.so.2")[pc]
        }

        if ($*pt->numline < 65536) {
            return first + @cast(lineinfo, "uint16_t", "/proc/2091042/root/openresty-wg/target/luajit/lib/libluajit-5.1.so.2")[pc]
        }

        return first + @cast(lineinfo, "uint32_t", "/proc/2091042/root/openresty-wg/target/luajit/lib/libluajit-5.1.so.2")[pc]
    }

    return -1
}